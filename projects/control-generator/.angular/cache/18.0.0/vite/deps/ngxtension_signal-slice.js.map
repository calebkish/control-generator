{
  "version": 3,
  "sources": ["../../../../../node_modules/ngxtension/fesm2022/ngxtension-assert-injector.mjs", "../../../../../node_modules/ngxtension/fesm2022/ngxtension-connect.mjs", "../../../../../node_modules/ngxtension/fesm2022/ngxtension-signal-slice.mjs"],
  "sourcesContent": ["import { assertInInjectionContext, Injector, inject, runInInjectionContext } from '@angular/core';\n\nfunction assertInjector(fn, injector, runner) {\n    !injector && assertInInjectionContext(fn);\n    const assertedInjector = injector ?? inject(Injector);\n    if (!runner)\n        return assertedInjector;\n    return runInInjectionContext(assertedInjector, runner);\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { assertInjector };\n\n", "import { DestroyRef, untracked, Injector, effect } from '@angular/core';\nimport { takeUntilDestroyed } from '@angular/core/rxjs-interop';\nimport { assertInjector } from 'ngxtension/assert-injector';\nimport { Subscription, isObservable } from 'rxjs';\n\nfunction connect(signal, ...args) {\n    const [observable, reducer, injectorOrDestroyRef, useUntracked, originSignal,] = parseArgs(args);\n    if (observable) {\n        let destroyRef = null;\n        if (injectorOrDestroyRef instanceof DestroyRef) {\n            destroyRef = injectorOrDestroyRef; // if it's a DestroyRef, use it\n        }\n        else {\n            const injector = assertInjector(connect, injectorOrDestroyRef);\n            destroyRef = injector.get(DestroyRef);\n        }\n        return observable.pipe(takeUntilDestroyed(destroyRef)).subscribe((x) => {\n            const update = () => {\n                signal.update((prev) => {\n                    if (!isObject(prev)) {\n                        return reducer?.(prev, x) || x;\n                    }\n                    if (!isObject(x)) {\n                        const reducedValue = reducer ? reducer(prev, x) : x;\n                        return isObject(reducedValue)\n                            ? { ...prev, ...reducedValue }\n                            : reducedValue;\n                    }\n                    return { ...prev, ...(reducer?.(prev, x) || x) };\n                });\n            };\n            if (useUntracked) {\n                untracked(update);\n            }\n            else {\n                update();\n            }\n        });\n    }\n    if (originSignal) {\n        const injector = injectorOrDestroyRef instanceof Injector\n            ? assertInjector(connect, injectorOrDestroyRef)\n            : undefined;\n        return effect(() => {\n            signal.update((prev) => {\n                if (!isObject(prev)) {\n                    return originSignal();\n                }\n                return { ...prev, ...originSignal() };\n            });\n        }, {\n            allowSignalWrites: true,\n            injector,\n        });\n    }\n    return {\n        with(...args) {\n            if (!this.subscription) {\n                this.subscription = new Subscription();\n            }\n            else if (this.subscription.closed) {\n                console.info(`[ngxtension connect] ConnectedSignal has been closed.`);\n                return this;\n            }\n            this.subscription.add(connect(signal, ...args, injectorOrDestroyRef, useUntracked));\n            return this;\n        },\n        subscription: null,\n    };\n}\n// TODO: there must be a way to parse the args more efficiently\nfunction parseArgs(args) {\n    if (args.length > 3) {\n        return [\n            args[0],\n            args[1],\n            args[2],\n            args[3],\n            null,\n        ];\n    }\n    if (args.length === 3) {\n        if (typeof args[2] === 'boolean') {\n            if (isObservable(args[0])) {\n                return [\n                    args[0],\n                    null,\n                    args[1],\n                    args[2],\n                    null,\n                ];\n            }\n            else {\n                return [\n                    null,\n                    null,\n                    args[1],\n                    args[2],\n                    args[0],\n                ];\n            }\n        }\n        return [\n            args[0],\n            args[1],\n            args[2],\n            false,\n            null,\n        ];\n    }\n    if (args.length === 2) {\n        if (typeof args[1] === 'boolean') {\n            return [null, null, args[0], args[1], null];\n        }\n        if (typeof args[1] === 'function') {\n            return [\n                args[0],\n                args[1],\n                null,\n                false,\n                null,\n            ];\n        }\n        return [\n            args[0],\n            null,\n            args[1],\n            false,\n            null,\n        ];\n    }\n    if (isObservable(args[0])) {\n        return [args[0], null, null, false, null];\n    }\n    // to connect signals to other signals, we need to use a callback that includes a signal call\n    if (typeof args[0] === 'function') {\n        return [null, null, null, false, args[0]];\n    }\n    return [null, null, args[0], false, null];\n}\nfunction isObject(val) {\n    return (typeof val === 'object' &&\n        val !== undefined &&\n        val !== null &&\n        !Array.isArray(val));\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { connect };\n\n", "import { DestroyRef, inject, Injector, signal, computed, effect } from '@angular/core';\nimport { toObservable, takeUntilDestroyed } from '@angular/core/rxjs-interop';\nimport { connect } from 'ngxtension/connect';\nimport { Subject, isObservable, share, take } from 'rxjs';\n\nfunction signalSlice(config) {\n    const destroyRef = inject(DestroyRef);\n    const injector = inject(Injector);\n    const { initialState, sources = [], lazySources = [], actionSources = {}, selectors = (() => ({})), effects = (() => ({})), actionEffects = (() => ({})), } = config;\n    const state = signal(initialState);\n    const readonlyState = state.asReadonly();\n    const state$ = toObservable(state);\n    let lazySourcesLoaded = false;\n    const subs = [];\n    const slice = readonlyState;\n    connectSources(state, sources);\n    for (const [key, actionSource] of Object.entries(actionSources)) {\n        const effectTrigger = new Subject();\n        subs.push(effectTrigger);\n        if (isObservable(actionSource)) {\n            addReducerProperties(readonlyState, state$, key, destroyRef, actionSource, subs, effectTrigger);\n        }\n        else {\n            const subject = new Subject();\n            const observable = actionSource(readonlyState, subject);\n            const sharedObservable = observable.pipe(share());\n            connect(state, sharedObservable);\n            addReducerProperties(readonlyState, state$, key, destroyRef, subject, subs, effectTrigger, sharedObservable);\n        }\n        const actionEffectFns = actionEffects(slice);\n        effectTrigger.subscribe((action) => {\n            const effectFn = actionEffectFns[action.name];\n            if (effectFn) {\n                effectFn(action);\n            }\n        });\n    }\n    for (const key in initialState) {\n        Object.defineProperty(readonlyState, key, {\n            value: computed(() => readonlyState()[key]),\n        });\n    }\n    for (const [key, selector] of Object.entries(selectors(slice))) {\n        Object.defineProperty(readonlyState, key, {\n            value: computed(selector),\n        });\n    }\n    for (const [key, namedEffect] of Object.entries(effects(slice))) {\n        Object.defineProperty(slice, key, {\n            value: effect((onCleanup) => {\n                const maybeCleanup = namedEffect();\n                if (maybeCleanup) {\n                    onCleanup(() => maybeCleanup());\n                }\n            }),\n        });\n    }\n    destroyRef.onDestroy(() => {\n        subs.forEach((sub) => sub.complete());\n    });\n    const connectLazySources = () => {\n        if (!lazySourcesLoaded) {\n            lazySourcesLoaded = true;\n            connectSources(state, lazySources, injector, true);\n        }\n    };\n    return new Proxy(slice, {\n        get(target, property, receiver) {\n            connectLazySources();\n            return Reflect.get(target, property, receiver);\n        },\n        apply(target, thisArg, argumentsList) {\n            connectLazySources();\n            return Reflect.apply(target, thisArg, argumentsList);\n        },\n    });\n}\nfunction connectSources(state, sources, injector, useUntracked = false) {\n    for (const source of sources) {\n        if (isObservable(source)) {\n            connect(state, source, injector, useUntracked);\n        }\n        else {\n            connect(state, source(state.asReadonly()), injector, useUntracked);\n        }\n    }\n}\nfunction addReducerProperties(readonlyState, state$, key, destroyRef, subject, subs, effectTrigger, observableFromActionSource) {\n    Object.defineProperties(readonlyState, {\n        [key]: {\n            value: (nextValue) => {\n                if (isObservable(nextValue)) {\n                    return new Promise((res, rej) => {\n                        nextValue.pipe(takeUntilDestroyed(destroyRef)).subscribe({\n                            next: (value) => {\n                                effectTrigger.next({\n                                    name: key,\n                                    payload: nextValue,\n                                    value,\n                                    err: undefined,\n                                });\n                                subject.next(value);\n                            },\n                            error: (err) => {\n                                effectTrigger.next({\n                                    name: key,\n                                    payload: nextValue,\n                                    value: undefined,\n                                    err,\n                                });\n                                subject.error(err);\n                                rej(err);\n                            },\n                            complete: () => {\n                                subject.complete();\n                                res(readonlyState());\n                            },\n                        });\n                    });\n                }\n                if (observableFromActionSource) {\n                    observableFromActionSource\n                        .pipe(takeUntilDestroyed(destroyRef))\n                        .subscribe({\n                        next: (value) => {\n                            effectTrigger.next({\n                                name: key,\n                                payload: nextValue,\n                                value,\n                                err: undefined,\n                            });\n                        },\n                        error: (err) => {\n                            effectTrigger.next({\n                                name: key,\n                                payload: nextValue,\n                                value: undefined,\n                                err,\n                            });\n                        },\n                    });\n                }\n                return new Promise((res) => {\n                    state$.pipe(take(1)).subscribe((val) => {\n                        res(val);\n                    });\n                    subject.next(nextValue);\n                });\n            },\n        },\n        [`${key}$`]: {\n            value: subject.asObservable(),\n        },\n    });\n    subs.push(subject);\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { signalSlice };\n\n"],
  "mappings": "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",
  "names": ["signal", "args"]
}
